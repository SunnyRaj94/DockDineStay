from typing import List, Optional
from bson import ObjectId
from pymongo import AsyncMongoClient
from fastapi import HTTPException, status
from dockdinestay.db.utils import (
    default_time,
    CafeteriaTableStatus,
)


from dockdinestay.db.models import CafeteriaTable


class CafeteriaTableCRUD:
    """
    CRUD operations for the CafeteriaTable collection.
    """

    def __init__(self, database: AsyncMongoClient):
        self.collection = (
            database.cafeteria_tables
        )  # Access the 'cafeteria_tables' collection

    async def _process_cafeteria_table_doc(self, table_doc: dict) -> CafeteriaTable:
        """
        Helper method to process raw MongoDB document before Pydantic validation.
        Ensures _id (ObjectId) is converted to string for PyObjectId.
        """
        if table_doc and "_id" in table_doc and isinstance(table_doc["_id"], ObjectId):
            table_doc["id"] = str(table_doc["_id"])
            del table_doc["_id"]
        return CafeteriaTable.model_validate(table_doc)

    async def create_table(self, table_data: CafeteriaTable) -> CafeteriaTable:
        """
        Creates a new cafeteria table in the database.
        Checks for duplicate table number.
        """
        if table_data.id:
            table_data.id = None  # Ensure ID is generated by default_factory or MongoDB

        # Check if table_number already exists
        if await self.collection.find_one({"table_number": table_data.table_number}):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Table number '{table_data.table_number}' already exists.",
            )

        # Set default status, created_at, updated_at if not provided
        if not table_data.status:
            table_data.status = CafeteriaTableStatus.available  # Default status
        if not table_data.created_at:
            table_data.created_at = default_time()
        if not table_data.updated_at:
            table_data.updated_at = default_time()

        table_dict = table_data.model_dump(by_alias=True, exclude_unset=True)
        insert_result = await self.collection.insert_one(table_dict)

        created_table_doc = await self.collection.find_one(
            {"_id": insert_result.inserted_id}
        )
        if created_table_doc:
            return await self._process_cafeteria_table_doc(created_table_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create cafeteria table",
        )

    async def get_all_tables(self) -> List[CafeteriaTable]:
        """
        Retrieves all cafeteria tables from the database.
        """
        tables = []
        async for table_doc in self.collection.find():
            tables.append(await self._process_cafeteria_table_doc(table_doc))
        return tables

    async def get_table_by_id(self, table_id: str) -> Optional[CafeteriaTable]:
        """
        Retrieves a single cafeteria table by its ID.
        """
        if not ObjectId.is_valid(table_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        table_doc = await self.collection.find_one({"_id": ObjectId(table_id)})
        if table_doc:
            return await self._process_cafeteria_table_doc(table_doc)
        return None

    async def update_table(
        self, table_id: str, table_data: CafeteriaTable
    ) -> Optional[CafeteriaTable]:
        """
        Updates an existing cafeteria table's information.
        """
        if not ObjectId.is_valid(table_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        update_data = table_data.model_dump(by_alias=True, exclude_unset=True)
        update_data.pop("_id", None)  # Ensure _id is not updated
        update_data.pop("id", None)  # Ensure 'id' is not updated

        # Prevent changing table_number to an existing one (if table_number is in update_data)
        if "table_number" in update_data:
            existing_table = await self.collection.find_one(
                {
                    "table_number": update_data["table_number"],
                    "_id": {"$ne": ObjectId(table_id)},
                }
            )
            if existing_table:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Table number '{update_data['table_number']}' already exists for another table.",
                )

        # Update updated_at timestamp
        update_data["updated_at"] = default_time()

        result = await self.collection.update_one(
            {"_id": ObjectId(table_id)}, {"$set": update_data}
        )

        if result.modified_count == 0:
            if not await self.collection.find_one({"_id": ObjectId(table_id)}):
                return None  # Table not found
            raise HTTPException(
                status_code=status.HTTP_304_NOT_MODIFIED,
                detail="Table data not modified",
            )

        updated_table_doc = await self.collection.find_one({"_id": ObjectId(table_id)})
        if updated_table_doc:
            return await self._process_cafeteria_table_doc(updated_table_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve updated table",
        )

    async def delete_table(self, table_id: str) -> bool:
        """
        Deletes a cafeteria table from the database by its ID.
        Returns True if deleted, False if not found.
        """
        if not ObjectId.is_valid(table_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        delete_result = await self.collection.delete_one({"_id": ObjectId(table_id)})
        return delete_result.deleted_count > 0
