from typing import List, Optional
from bson import ObjectId
from pymongo import AsyncMongoClient
from fastapi import HTTPException, status
from dockdinestay.db.utils import default_time, PyObjectId, datetime, timezone
from dockdinestay.db.models import BoatBooking, BoatBookingStatus, BoatStatus


class BoatBookingCRUD:
    """
    CRUD operations for the BoatBooking collection.
    Handles dependencies on User and Boat collections for validation and availability.
    """

    def __init__(self, database: AsyncMongoClient):
        self.collection = database.boat_bookings
        self.users_collection = database.users
        self.boats_collection = database.boats

    async def _process_booking_doc(self, booking_doc: dict) -> BoatBooking:
        """
        Helper method to process raw MongoDB document before Pydantic validation.
        Ensures _id (ObjectId) is converted to string for PyObjectId.
        """
        if (
            booking_doc
            and "_id" in booking_doc
            and isinstance(booking_doc["_id"], ObjectId)
        ):
            booking_doc["id"] = str(booking_doc["_id"])
            del booking_doc["_id"]
        return BoatBooking.model_validate(booking_doc)

    async def _check_boat_availability(
        self,
        boat_id: PyObjectId,
        start_time: datetime,
        end_time: datetime,
        exclude_booking_id: Optional[
            ObjectId
        ] = None,  # For updates, exclude current booking
    ) -> bool:
        """
        Checks if the specified boat is available for the given time range.
        Considers confirmed and rented bookings.
        """
        # Ensure datetimes are timezone-aware and in UTC for consistent comparison
        start_time_utc = start_time.astimezone(timezone.utc)
        end_time_utc = end_time.astimezone(timezone.utc)

        # 1. Check if boat exists and is not out_of_service or in_maintenance
        boat_doc = await self.boats_collection.find_one({"_id": boat_id})
        if not boat_doc:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, detail="Boat not found."
            )

        boat_status = boat_doc.get("status")
        if boat_status in [BoatStatus.out_of_service, BoatStatus.maintenance]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Boat '{boat_doc.get('boat_name')}' is currently {boat_status.replace('_', ' ')}.",
            )

        # 2. Check for overlapping bookings
        # An overlap occurs if an existing booking's time range [exist_start, exist_end]
        # intersects with the new booking's time range [start_time, end_time].
        # This is true if (exist_start < end_time AND exist_end > start_time)

        query = {
            "boat_id": boat_id,
            "status": {
                "$in": [BoatBookingStatus.confirmed, BoatBookingStatus.rented]
            },  # Only consider active bookings
            "$or": [
                {
                    "start_time": {
                        "$lt": end_time_utc
                    },  # Existing booking starts before new one ends
                    "end_time": {
                        "$gt": start_time_utc
                    },  # Existing booking ends after new one starts
                }
            ],
        }

        if exclude_booking_id:
            query["_id"] = {"$ne": exclude_booking_id}

        existing_booking = await self.collection.find_one(query)

        return existing_booking is None  # Return True if no overlapping booking found

    async def create_booking(self, booking_data: BoatBooking) -> BoatBooking:
        """
        Creates a new boat booking.
        Validates user_id, boat_id, and checks for boat availability.
        Calculates total_price.
        """
        if booking_data.id:
            booking_data.id = (
                None  # Ensure ID is generated by default_factory or MongoDB
            )

        # 1. Validate user_id
        user_doc = await self.users_collection.find_one({"_id": booking_data.user_id})
        if not user_doc:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, detail="User not found."
            )

        # 2. Validate time range
        now_utc = default_time()
        booking_data.start_time = booking_data.start_time.astimezone(timezone.utc)
        booking_data.end_time = booking_data.end_time.astimezone(timezone.utc)

        if booking_data.start_time < now_utc:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Booking start time cannot be in the past.",
            )
        if booking_data.end_time <= booking_data.start_time:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Booking end time must be after start time.",
            )

        # 3. Check boat availability and existence
        boat_doc = await self.boats_collection.find_one({"_id": booking_data.boat_id})
        if not boat_doc:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, detail="Boat not found."
            )

        if not await self._check_boat_availability(
            booking_data.boat_id, booking_data.start_time, booking_data.end_time
        ):
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=f"Boat '{boat_doc.get('boat_name')}' is not available during the requested time.",
            )

        # 4. Calculate total_price
        hourly_rate = boat_doc.get("hourly_rate", 0.0)
        duration_hours = (
            booking_data.end_time - booking_data.start_time
        ).total_seconds() / 3600
        booking_data.total_price = round(hourly_rate * duration_hours, 2)

        # Set default status, created_at, updated_at
        if not booking_data.status:
            booking_data.status = BoatBookingStatus.pending
        if not booking_data.created_at:
            booking_data.created_at = default_time()
        if not booking_data.updated_at:
            booking_data.updated_at = default_time()

        booking_dict = booking_data.model_dump(by_alias=True, exclude_unset=True)
        insert_result = await self.collection.insert_one(booking_dict)

        created_booking_doc = await self.collection.find_one(
            {"_id": insert_result.inserted_id}
        )
        if created_booking_doc:
            return await self._process_booking_doc(created_booking_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create boat booking",
        )

    async def get_all_bookings(self) -> List[BoatBooking]:
        """
        Retrieves all boat bookings.
        """
        bookings = []
        async for booking_doc in self.collection.find():
            bookings.append(await self._process_booking_doc(booking_doc))
        return bookings

    async def get_booking_by_id(self, booking_id: str) -> Optional[BoatBooking]:
        """
        Retrieves a single boat booking by its ID.
        """
        if not ObjectId.is_valid(booking_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        booking_doc = await self.collection.find_one({"_id": ObjectId(booking_id)})
        if booking_doc:
            return await self._process_booking_doc(booking_doc)
        return None

    async def update_booking(
        self, booking_id: str, booking_data: BoatBooking
    ) -> Optional[BoatBooking]:
        """
        Updates an existing boat booking's information.
        Re-validates time range and recalculates total_price if necessary.
        """
        if not ObjectId.is_valid(booking_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        current_booking_doc = await self.collection.find_one(
            {"_id": ObjectId(booking_id)}
        )
        if not current_booking_doc:
            return None  # Booking not found

        update_data = booking_data.model_dump(by_alias=True, exclude_unset=True)
        update_data.pop("_id", None)
        update_data.pop("id", None)

        # Prevent changing user_id or boat_id after creation
        if (
            "user_id" in update_data
            and update_data["user_id"] != current_booking_doc["user_id"]
        ):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User ID cannot be changed in an existing booking.",
            )
        if (
            "boat_id" in update_data
            and update_data["boat_id"] != current_booking_doc["boat_id"]
        ):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Boat ID cannot be changed in an existing booking.",
            )
        if (
            "created_at" in update_data
            and update_data["created_at"] != current_booking_doc["created_at"]
        ):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Creation timestamp cannot be changed in an existing booking.",
            )

        # Only proceed with time/availability checks if start_time or end_time is provided
        # or if the status implies new checks (e.g., changing from 'cancelled' to 'confirmed')
        perform_time_check = False
        new_start_time = update_data.get(
            "start_time", current_booking_doc["start_time"]
        )
        new_end_time = update_data.get("end_time", current_booking_doc["end_time"])
        new_status = update_data.get("status", current_booking_doc["status"])

        if (
            new_start_time != current_booking_doc["start_time"]
            or new_end_time != current_booking_doc["end_time"]
            or (
                current_booking_doc["status"] == BoatBookingStatus.cancelled
                and new_status == BoatBookingStatus.confirmed
            )
        ):
            perform_time_check = True  # noqa

            # Ensure datetimes are timezone-aware before comparison
            new_start_time = new_start_time.astimezone(timezone.utc)
            new_end_time = new_end_time.astimezone(timezone.utc)

            now_utc = default_time()
            if (
                new_start_time < now_utc
                and current_booking_doc["start_time"].astimezone(timezone.utc)
                >= now_utc
            ):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Cannot move booking start time to the past.",
                )
            if new_end_time <= new_start_time:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Booking end time must be after start time.",
                )

            # Re-check availability for the updated time slot, excluding the current booking
            if not await self._check_boat_availability(
                current_booking_doc["boat_id"],
                new_start_time,
                new_end_time,
                ObjectId(booking_id),
            ):
                raise HTTPException(
                    status_code=status.HTTP_409_CONFLICT,
                    detail="Boat is not available for the updated time slot.",
                )

            # Recalculate total price if time or boat changes
            boat_doc = await self.boats_collection.find_one(
                {"_id": current_booking_doc["boat_id"]}
            )
            hourly_rate = boat_doc.get("hourly_rate", 0.0)
            duration_hours = (new_end_time - new_start_time).total_seconds() / 3600
            update_data["total_price"] = round(hourly_rate * duration_hours, 2)

            # Update start_time and end_time in update_data
            update_data["start_time"] = new_start_time
            update_data["end_time"] = new_end_time

        # Update updated_at timestamp
        update_data["updated_at"] = default_time()

        result = await self.collection.update_one(
            {"_id": ObjectId(booking_id)}, {"$set": update_data}
        )

        if result.modified_count == 0:
            if not await self.collection.find_one({"_id": ObjectId(booking_id)}):
                return None  # Booking not found
            raise HTTPException(
                status_code=status.HTTP_304_NOT_MODIFIED,
                detail="Boat booking data not modified",
            )

        updated_booking_doc = await self.collection.find_one(
            {"_id": ObjectId(booking_id)}
        )
        if updated_booking_doc:
            return await self._process_booking_doc(updated_booking_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve updated boat booking",
        )

    async def delete_booking(self, booking_id: str) -> bool:
        """
        Deletes a boat booking from the database by its ID.
        Returns True if deleted, False if not found.
        """
        if not ObjectId.is_valid(booking_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        delete_result = await self.collection.delete_one({"_id": ObjectId(booking_id)})
        return delete_result.deleted_count > 0
