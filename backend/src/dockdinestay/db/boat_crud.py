from typing import List, Optional
from bson import ObjectId
from pymongo import AsyncMongoClient
from fastapi import HTTPException, status
from dockdinestay.db.utils import default_time
from dockdinestay.db.models import Boat, BoatStatus


class BoatCRUD:
    """
    CRUD operations for the Boat collection.
    """

    def __init__(self, database: AsyncMongoClient):
        self.collection = database.boats  # Access the 'boats' collection

    async def _process_boat_doc(self, boat_doc: dict) -> Boat:
        """
        Helper method to process raw MongoDB document before Pydantic validation.
        Ensures _id (ObjectId) is converted to string for PyObjectId.
        """
        if boat_doc and "_id" in boat_doc and isinstance(boat_doc["_id"], ObjectId):
            boat_doc["id"] = str(boat_doc["_id"])
            del boat_doc["_id"]
        return Boat.model_validate(boat_doc)

    async def create_boat(self, boat_data: Boat) -> Boat:
        """
        Creates a new boat in the database.
        Checks for duplicate boat name.
        """
        if boat_data.id:
            boat_data.id = None  # Ensure ID is generated by default_factory or MongoDB

        # Check if boat_name already exists (case-insensitive check might be better)
        if await self.collection.find_one(
            {"boat_name": {"$regex": f"^{boat_data.boat_name}$", "$options": "i"}}
        ):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Boat with name '{boat_data.boat_name}' already exists.",
            )

        # Set default status, created_at, updated_at if not provided
        if not boat_data.status:
            boat_data.status = BoatStatus.available  # Default status
        if not boat_data.created_at:
            boat_data.created_at = default_time()
        if not boat_data.updated_at:
            boat_data.updated_at = default_time()

        boat_dict = boat_data.model_dump(by_alias=True, exclude_unset=True)
        insert_result = await self.collection.insert_one(boat_dict)

        created_boat_doc = await self.collection.find_one(
            {"_id": insert_result.inserted_id}
        )
        if created_boat_doc:
            return await self._process_boat_doc(created_boat_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create boat",
        )

    async def get_all_boats(self) -> List[Boat]:
        """
        Retrieves all boats from the database.
        """
        boats = []
        async for boat_doc in self.collection.find():
            boats.append(await self._process_boat_doc(boat_doc))
        return boats

    async def get_boat_by_id(self, boat_id: str) -> Optional[Boat]:
        """
        Retrieves a single boat by its ID.
        """
        if not ObjectId.is_valid(boat_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        boat_doc = await self.collection.find_one({"_id": ObjectId(boat_id)})
        if boat_doc:
            return await self._process_boat_doc(boat_doc)
        return None

    async def update_boat(self, boat_id: str, boat_data: Boat) -> Optional[Boat]:
        """
        Updates an existing boat's information.
        """
        if not ObjectId.is_valid(boat_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        update_data = boat_data.model_dump(by_alias=True, exclude_unset=True)
        update_data.pop("_id", None)  # Ensure _id is not updated
        update_data.pop("id", None)  # Ensure 'id' is not updated

        # Prevent changing boat_name to an existing one (if boat_name is in update_data)
        if "boat_name" in update_data:
            existing_boat = await self.collection.find_one(
                {
                    "boat_name": {
                        "$regex": f"^{update_data['boat_name']}$",
                        "$options": "i",
                    },
                    "_id": {"$ne": ObjectId(boat_id)},
                }
            )
            if existing_boat:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Boat with name '{update_data['boat_name']}' already exists for another boat.",
                )

        # Update updated_at timestamp
        update_data["updated_at"] = default_time()

        result = await self.collection.update_one(
            {"_id": ObjectId(boat_id)}, {"$set": update_data}
        )

        if result.modified_count == 0:
            if not await self.collection.find_one({"_id": ObjectId(boat_id)}):
                return None  # Boat not found
            raise HTTPException(
                status_code=status.HTTP_304_NOT_MODIFIED,
                detail="Boat data not modified",
            )

        updated_boat_doc = await self.collection.find_one({"_id": ObjectId(boat_id)})
        if updated_boat_doc:
            return await self._process_boat_doc(updated_boat_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve updated boat",
        )

    async def delete_boat(self, boat_id: str) -> bool:
        """
        Deletes a boat from the database by its ID.
        Returns True if deleted, False if not found.
        """
        if not ObjectId.is_valid(boat_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        delete_result = await self.collection.delete_one({"_id": ObjectId(boat_id)})
        return delete_result.deleted_count > 0
