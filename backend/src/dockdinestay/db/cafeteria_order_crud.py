from typing import List, Optional
from bson import ObjectId
from pymongo import AsyncMongoClient
from fastapi import HTTPException, status
from dockdinestay.db.utils import (
    default_time,
    CafeteriaOrderStatus,
)
from dockdinestay.db.models import OrderItemDetail, CafeteriaOrder


class CafeteriaOrderCRUD:
    """
    CRUD operations for the CafeteriaOrder collection.
    Handles dependencies on User, CafeteriaTable, and CafeteriaOrderItem collections for validation.
    """

    def __init__(self, database: AsyncMongoClient):
        self.collection = database.cafeteria_orders
        self.users_collection = database.users
        self.tables_collection = database.cafeteria_tables
        self.menu_items_collection = (
            database.cafeteria_order_items
        )  # Assuming this is your menu items collection

    async def _process_order_doc(self, order_doc: dict) -> CafeteriaOrder:
        """
        Helper method to process raw MongoDB document before Pydantic validation.
        Ensures _id (ObjectId) is converted to string for PyObjectId.
        """
        if order_doc and "_id" in order_doc and isinstance(order_doc["_id"], ObjectId):
            order_doc["id"] = str(order_doc["_id"])
            del order_doc["_id"]
        return CafeteriaOrder.model_validate(order_doc)

    async def create_order(self, order_data: CafeteriaOrder) -> CafeteriaOrder:
        """
        Creates a new cafeteria order.
        Validates user_id, table_id, and each order item. Calculates total_amount.
        """
        if order_data.id:
            order_data.id = None  # Ensure ID is generated by default_factory or MongoDB

        # 1. Validate user_id
        user_doc = await self.users_collection.find_one({"_id": order_data.user_id})
        if not user_doc:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_MESSAGE, detail="User not found."
            )

        # 2. Validate table_id
        table_doc = await self.tables_collection.find_one({"_id": order_data.table_id})
        if not table_doc:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Cafeteria table not found.",
            )

        # 3. Validate items and calculate total_amount
        total_amount = 0.0
        processed_items: List[OrderItemDetail] = []

        for item_detail in order_data.items:
            menu_item_doc = await self.menu_items_collection.find_one(
                {"_id": item_detail.item_id}
            )
            if not menu_item_doc:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail=f"Menu item with ID '{item_detail.item_id}' not found.",
                )

            # Use the actual price from the menu item and check availability
            if not menu_item_doc.get("is_available"):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Menu item '{menu_item_doc.get('item_name')}' is currently not available.",
                )

            current_price = menu_item_doc.get("price", 0.0)

            # Create a new OrderItemDetail instance with the actual menu item data
            processed_item = OrderItemDetail(
                item_id=item_detail.item_id,
                item_name=menu_item_doc.get("item_name"),  # Take name from menu item
                quantity=item_detail.quantity,
                price_at_time_of_order=current_price,  # Use current price from menu
                notes=item_detail.notes,
            )
            processed_items.append(processed_item)
            total_amount += (
                processed_item.quantity * processed_item.price_at_time_of_order
            )

        order_data.items = processed_items
        order_data.total_amount = total_amount

        # Set default status, created_at, updated_at if not provided
        if not order_data.status:
            order_data.status = CafeteriaOrderStatus.pending
        if not order_data.order_time:
            order_data.order_time = default_time()
        if not order_data.updated_at:
            order_data.updated_at = default_time()

        order_dict = order_data.model_dump(by_alias=True, exclude_unset=True)
        insert_result = await self.collection.insert_one(order_dict)

        created_order_doc = await self.collection.find_one(
            {"_id": insert_result.inserted_id}
        )
        if created_order_doc:
            return await self._process_order_doc(created_order_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create cafeteria order",
        )

    async def get_all_orders(self) -> List[CafeteriaOrder]:
        """
        Retrieves all cafeteria orders.
        """
        orders = []
        async for order_doc in self.collection.find():
            orders.append(await self._process_order_doc(order_doc))
        return orders

    async def get_order_by_id(self, order_id: str) -> Optional[CafeteriaOrder]:
        """
        Retrieves a single cafeteria order by its ID.
        """
        if not ObjectId.is_valid(order_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        order_doc = await self.collection.find_one({"_id": ObjectId(order_id)})
        if order_doc:
            return await self._process_order_doc(order_doc)
        return None

    async def update_order(
        self, order_id: str, order_data: CafeteriaOrder
    ) -> Optional[CafeteriaOrder]:
        """
        Updates an existing cafeteria order's information.
        Re-validates and recalculates total_amount if items change.
        """
        if not ObjectId.is_valid(order_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        current_order_doc = await self.collection.find_one({"_id": ObjectId(order_id)})
        if not current_order_doc:
            return None  # Order not found

        update_data = order_data.model_dump(by_alias=True, exclude_unset=True)
        update_data.pop("_id", None)
        update_data.pop("id", None)

        # User ID and Order Time typically should not be changed on update
        if (
            "user_id" in update_data
            and update_data["user_id"] != current_order_doc["user_id"]
        ):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User ID cannot be changed in an existing order.",
            )
        if (
            "order_time" in update_data
            and update_data["order_time"] != current_order_doc["order_time"]
        ):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Order time cannot be changed in an existing order.",
            )

        # Re-validate table_id if it's being updated
        if (
            "table_id" in update_data
            and update_data["table_id"] != current_order_doc["table_id"]
        ):
            table_doc = await self.tables_collection.find_one(
                {"_id": update_data["table_id"]}
            )
            if not table_doc:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="Cafeteria table not found for update.",
                )

        # Re-validate items and recalculate total_amount if items list is provided in update
        if "items" in update_data:
            total_amount = 0.0
            processed_items: List[OrderItemDetail] = []
            for item_detail_dict in update_data["items"]:  # update_data is a dict here
                # Convert dict back to Pydantic model for validation convenience
                item_detail = OrderItemDetail(**item_detail_dict)

                menu_item_doc = await self.menu_items_collection.find_one(
                    {"_id": item_detail.item_id}
                )
                if not menu_item_doc:
                    raise HTTPException(
                        status_code=status.HTTP_404_NOT_FOUND,
                        detail=f"Menu item with ID '{item_detail.item_id}' not found for update.",
                    )

                if not menu_item_doc.get("is_available"):
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail=f"Menu item '{menu_item_doc.get('item_name')}' is currently not available.",
                    )

                current_price = menu_item_doc.get("price", 0.0)

                processed_item = OrderItemDetail(
                    item_id=item_detail.item_id,
                    item_name=menu_item_doc.get("item_name"),
                    quantity=item_detail.quantity,
                    price_at_time_of_order=current_price,
                    notes=item_detail.notes,
                )
                processed_items.append(processed_item)
                total_amount += (
                    processed_item.quantity * processed_item.price_at_time_of_order
                )

            update_data["items"] = [
                item.model_dump(by_alias=True) for item in processed_items
            ]  # Convert back to dict for MongoDB
            update_data["total_amount"] = total_amount

        # Update updated_at timestamp
        update_data["updated_at"] = default_time()

        result = await self.collection.update_one(
            {"_id": ObjectId(order_id)}, {"$set": update_data}
        )

        if result.modified_count == 0:
            # Check if order exists before claiming no modification
            if not await self.collection.find_one({"_id": ObjectId(order_id)}):
                return None  # Order not found
            raise HTTPException(
                status_code=status.HTTP_304_NOT_MODIFIED,
                detail="Order data not modified",
            )

        updated_order_doc = await self.collection.find_one({"_id": ObjectId(order_id)})
        if updated_order_doc:
            return await self._process_order_doc(updated_order_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve updated order",
        )

    async def delete_order(self, order_id: str) -> bool:
        """
        Deletes a cafeteria order from the database by its ID.
        Returns True if deleted, False if not found.
        """
        if not ObjectId.is_valid(order_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        delete_result = await self.collection.delete_one({"_id": ObjectId(order_id)})
        return delete_result.deleted_count > 0
