from typing import List, Optional
from bson import ObjectId
from fastapi import HTTPException, status
from pymongo import AsyncMongoClient

from dockdinestay.db.utils import hash_password, default_time

from dockdinestay.db.models import User


class UserCRUD:
    """
    CRUD operations for the User collection.
    """

    def __init__(self, database: AsyncMongoClient):
        self.collection = database.users  # Access the 'users' collection

    async def create_user(self, user_data: User) -> User:
        """
        Creates a new user in the database.
        Hashes the password before insertion.
        Checks for duplicate username/email.
        """
        # Ensure ID is not provided by client, or rely on default_factory
        # if user_data.id:
        #     user_data.id = None  # Let default_factory handle new ObjectId

        # Hash the password before storing
        user_data.password = hash_password(user_data.password)

        # Check if username or email already exists
        if await self.collection.find_one({"username": user_data.username}):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already exists",
            )
        if user_data.email and await self.collection.find_one(
            {"email": user_data.email}
        ):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, detail="Email already exists"
            )

        # Convert Pydantic model to a dictionary suitable for MongoDB insertion
        user_dict = user_data.model_dump(by_alias=True, exclude_unset=True)

        insert_result = await self.collection.insert_one(user_dict)

        # Retrieve the inserted user with the actual _id generated by MongoDB
        created_user_doc = await self.collection.find_one(
            {"_id": insert_result.inserted_id}
        )
        if created_user_doc:
            created_user_doc["_id"] = created_user_doc["_id"].__str__()
            return User.model_validate(created_user_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create user",
        )

    async def get_all_users(self) -> List[User]:
        """
        Retrieves all users from the database.
        """
        users = []
        async for user_doc in self.collection.find():
            user_doc["_id"] = user_doc["_id"].__str__()
            users.append(User.model_validate(user_doc))
        return users

    async def get_user_by_id(self, user_id: str) -> Optional[User]:
        """
        Retrieves a single user by their ID.
        """
        if not ObjectId.is_valid(user_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        user_doc = await self.collection.find_one({"_id": ObjectId(user_id)})
        if user_doc:
            user_doc["_id"] = user_doc["_id"].__str__()
            return User.model_validate(user_doc)
        return None  # Return None if not found, let API endpoint handle 404

    async def update_user(self, user_id: str, user_data: User) -> Optional[User]:
        """
        Updates an existing user's information.
        Hashes the password if updated.
        """
        if not ObjectId.is_valid(user_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        # Exclude ID from update payload and fields that are None
        update_data = user_data.model_dump(by_alias=True, exclude_unset=True)
        update_data.pop("_id", None)  # Ensure _id is not updated

        # If password is being updated, hash it
        if "password" in update_data and update_data["password"]:
            update_data["password"] = hash_password(update_data["password"])

        # Update updated_at timestamp
        update_data["updated_at"] = default_time()

        # Perform the update
        result = await self.collection.update_one(
            {"_id": ObjectId(user_id)}, {"$set": update_data}
        )

        if result.modified_count == 0:
            # If no modification, check if user existed to differentiate 404 from 304
            if not await self.collection.find_one({"_id": ObjectId(user_id)}):
                return None  # User not found
            # User existed but no fields were modified
            raise HTTPException(
                status_code=status.HTTP_304_NOT_MODIFIED,
                detail="User data not modified",
            )

        # Fetch the updated document
        updated_user_doc = await self.collection.find_one({"_id": ObjectId(user_id)})
        if updated_user_doc:
            updated_user_doc["_id"] = updated_user_doc["_id"].__str__()
            return User.model_validate(updated_user_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve updated user",
        )

    async def delete_user(self, user_id: str) -> bool:
        """
        Deletes a user from the database by their ID.
        Returns True if deleted, False if not found.
        """
        if not ObjectId.is_valid(user_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        delete_result = await self.collection.delete_one({"_id": ObjectId(user_id)})
        return delete_result.deleted_count > 0
