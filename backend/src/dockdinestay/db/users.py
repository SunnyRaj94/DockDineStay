from typing import List, Optional
from bson import ObjectId
from fastapi import HTTPException, status
from pymongo import AsyncMongoClient

from dockdinestay.db.utils import default_time

from dockdinestay.db.models import User, UserRole, UpdateUser


class UserCRUD:
    """
    CRUD operations for the User collection.
    """

    def __init__(self, database: AsyncMongoClient):
        self.collection = database.users  # Access the 'users' collection

    async def _process_user_doc(self, user_doc: dict) -> User:
        """
        Helper method to process raw MongoDB document before Pydantic validation.
        Ensures _id (ObjectId) is converted to string for PyObjectId.
        """
        if user_doc and "_id" in user_doc and isinstance(user_doc["_id"], ObjectId):
            user_doc["id"] = str(user_doc["_id"])
            user_doc["_id"] = str(user_doc["_id"])
        return User.model_validate(user_doc)

    async def create_user(self, user_data: User) -> User:
        """
        Creates a new user in the database.
        Checks for duplicate username and email.
        """
        if user_data.id:
            user_data.id = None  # Ensure ID is generated by default_factory or MongoDB

        # Check if username already exists (case-insensitive)
        if await self.collection.find_one(
            {"username": {"$regex": f"^{user_data.username}$", "$options": "i"}}
        ):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"User with username '{user_data.username}' already exists.",
            )

        # Check if email already exists (case-insensitive)
        if await self.collection.find_one(
            {"email": {"$regex": f"^{user_data.email}$", "$options": "i"}}
        ):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"User with email '{user_data.email}' already exists.",
            )

        # Set default role, created_at, updated_at if not provided
        if not user_data.role:
            user_data.role = (
                UserRole.customer
            )  # Changed from guest as per common usage, but keep if you use guest
        if not user_data.created_at:
            user_data.created_at = default_time()
        if not user_data.updated_at:
            user_data.updated_at = default_time()

        user_dict = user_data.model_dump(by_alias=True, exclude_unset=True)
        insert_result = await self.collection.insert_one(user_dict)

        created_user_doc = await self.collection.find_one(
            {"_id": insert_result.inserted_id}
        )
        if created_user_doc:
            return await self._process_user_doc(created_user_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create user",
        )

    async def get_all_users(self) -> List[User]:
        """
        Retrieves all users from the database.
        """
        users = []
        async for user_doc in self.collection.find():
            users.append(await self._process_user_doc(user_doc))
        return users

    async def get_user_by_id(self, user_id: str) -> Optional[User]:
        """
        Retrieves a single user by their ID.
        """
        if not ObjectId.is_valid(user_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        user_doc = await self.collection.find_one({"_id": ObjectId(user_id)})
        if user_doc:
            return await self._process_user_doc(user_doc)
        return None

    # --- EXISTING METHOD: Get user by username ---
    async def get_user_by_username(self, username: str) -> Optional[User]:
        """
        Retrieves a single user by their username (case-insensitive).
        """
        user_doc = await self.collection.find_one(
            {"username": {"$regex": f"^{username}$", "$options": "i"}}
        )
        if user_doc:
            return await self._process_user_doc(user_doc)
        return None

    # --- MODIFIED: update_user to accept UpdateUser model ---
    async def update_user(
        self, user_id: str, user_data: UpdateUser
    ) -> Optional[User]:  # <-- CHANGED TYPE HINT TO UpdateUser
        """
        Updates an existing user's information.
        Accepts UpdateUser schema for partial updates.
        """
        if not ObjectId.is_valid(user_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        # Get the existing user document to check for unique constraints against
        existing_user_doc = await self.collection.find_one({"_id": ObjectId(user_id)})
        if not existing_user_doc:
            return None  # User not found

        # Use model_dump(exclude_unset=True) to get only the fields that were provided in the request
        update_data = user_data.model_dump(by_alias=True, exclude_unset=True)

        # Remove _id and id if they somehow got into update_data (Pydantic models generally prevent this for incoming data)
        update_data.pop("_id", None)
        update_data.pop("id", None)

        # Handle unique constraints for username and email ONLY IF THEY ARE PROVIDED IN THE UPDATE
        if "username" in update_data:
            # Check if username already exists for *another* user
            if await self.collection.find_one(
                {
                    "username": {
                        "$regex": f"^{update_data['username']}$",
                        "$options": "i",
                    },
                    "_id": {
                        "$ne": ObjectId(user_id)
                    },  # Ensure it's not the current user's own username
                }
            ):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"User with username '{update_data['username']}' already exists.",
                )
        if "email" in update_data:
            # Check if email already exists for *another* user
            if await self.collection.find_one(
                {
                    "email": {"$regex": f"^{update_data['email']}$", "$options": "i"},
                    "_id": {
                        "$ne": ObjectId(user_id)
                    },  # Ensure it's not the current user's own email
                }
            ):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"User with email '{update_data['email']}' already exists.",
                )

        # Update updated_at timestamp (always update on any change)
        update_data["updated_at"] = default_time()

        # If no actual fields were provided for update (apart from potentially 'updated_at' if we added it earlier),
        # then there's nothing to change. This can happen if frontend sends an empty body.
        # Check if update_data has any keys other than 'updated_at' if 'updated_at' is always added.
        if not update_data or (len(update_data) == 1 and "updated_at" in update_data):
            raise HTTPException(
                status_code=status.HTTP_304_NOT_MODIFIED,
                detail="No valid fields provided for update or no changes detected.",
            )

        result = await self.collection.update_one(
            {"_id": ObjectId(user_id)}, {"$set": update_data}
        )

        if result.modified_count == 0:
            # If the user existed but no fields were actually modified by MongoDB (because data was identical)
            # and we sent some valid fields (checked by the 'if not update_data' above)
            raise HTTPException(
                status_code=status.HTTP_304_NOT_MODIFIED,
                detail="User data not modified (data sent was identical to existing data).",
            )

        updated_user_doc = await self.collection.find_one({"_id": ObjectId(user_id)})
        if updated_user_doc:
            return await self._process_user_doc(updated_user_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve updated user after modification.",
        )

    async def delete_user(self, user_id: str) -> bool:
        """
        Deletes a user from the database by their ID.
        Returns True if deleted, False if not found.
        """
        if not ObjectId.is_valid(user_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        delete_result = await self.collection.delete_one({"_id": ObjectId(user_id)})
        return delete_result.deleted_count > 0
