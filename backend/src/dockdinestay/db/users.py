from typing import List, Optional
from bson import ObjectId
from fastapi import HTTPException, status
from pymongo import AsyncMongoClient

from dockdinestay.db.utils import default_time

from dockdinestay.db.models import User, UserRole


class UserCRUD:
    """
    CRUD operations for the User collection.
    """

    def __init__(self, database: AsyncMongoClient):
        self.collection = database.users  # Access the 'users' collection

    async def _process_user_doc(self, user_doc: dict) -> User:
        """
        Helper method to process raw MongoDB document before Pydantic validation.
        Ensures _id (ObjectId) is converted to string for PyObjectId.
        """
        if user_doc and "_id" in user_doc and isinstance(user_doc["_id"], ObjectId):
            user_doc["id"] = str(user_doc["_id"])
            del user_doc["_id"]
        return User.model_validate(user_doc)

    async def create_user(self, user_data: User) -> User:
        """
        Creates a new user in the database.
        Checks for duplicate username and email.
        """
        if user_data.id:
            user_data.id = None  # Ensure ID is generated by default_factory or MongoDB

        # Check if username already exists (case-insensitive)
        if await self.collection.find_one(
            {"username": {"$regex": f"^{user_data.username}$", "$options": "i"}}
        ):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"User with username '{user_data.username}' already exists.",
            )

        # Check if email already exists (case-insensitive)
        if await self.collection.find_one(
            {"email": {"$regex": f"^{user_data.email}$", "$options": "i"}}
        ):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"User with email '{user_data.email}' already exists.",
            )

        # Set default role, created_at, updated_at if not provided
        if not user_data.role:
            user_data.role = UserRole.guest  # Default role
        if not user_data.created_at:
            user_data.created_at = default_time()
        if not user_data.updated_at:
            user_data.updated_at = default_time()

        user_dict = user_data.model_dump(by_alias=True, exclude_unset=True)
        insert_result = await self.collection.insert_one(user_dict)

        created_user_doc = await self.collection.find_one(
            {"_id": insert_result.inserted_id}
        )
        if created_user_doc:
            return await self._process_user_doc(created_user_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create user",
        )

    async def get_all_users(self) -> List[User]:
        """
        Retrieves all users from the database.
        """
        users = []
        async for user_doc in self.collection.find():
            users.append(await self._process_user_doc(user_doc))
        return users

    async def get_user_by_id(self, user_id: str) -> Optional[User]:
        """
        Retrieves a single user by their ID.
        """
        if not ObjectId.is_valid(user_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        user_doc = await self.collection.find_one({"_id": ObjectId(user_id)})
        if user_doc:
            return await self._process_user_doc(user_doc)
        return None

    # --- NEW METHOD: Get user by username ---
    async def get_user_by_username(self, username: str) -> Optional[User]:
        """
        Retrieves a single user by their username (case-insensitive).
        """
        user_doc = await self.collection.find_one(
            {"username": {"$regex": f"^{username}$", "$options": "i"}}
        )
        if user_doc:
            return await self._process_user_doc(user_doc)
        return None

    # --- END NEW METHOD ---

    async def update_user(self, user_id: str, user_data: User) -> Optional[User]:
        """
        Updates an existing user's information.
        """
        if not ObjectId.is_valid(user_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        update_data = user_data.model_dump(by_alias=True, exclude_unset=True)
        update_data.pop("_id", None)  # Ensure _id is not updated
        update_data.pop("id", None)  # Ensure 'id' is not updated

        # Prevent changing username or email to an existing one (if in update_data)
        if "username" in update_data:
            existing_user = await self.collection.find_one(
                {
                    "username": {
                        "$regex": f"^{update_data['username']}$",
                        "$options": "i",
                    },
                    "_id": {"$ne": ObjectId(user_id)},
                }
            )
            if existing_user:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"User with username '{update_data['username']}' already exists.",
                )
        if "email" in update_data:
            existing_user = await self.collection.find_one(
                {
                    "email": {"$regex": f"^{update_data['email']}$", "$options": "i"},
                    "_id": {"$ne": ObjectId(user_id)},
                }
            )
            if existing_user:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"User with email '{update_data['email']}' already exists.",
                )

        # Update updated_at timestamp
        update_data["updated_at"] = default_time()

        result = await self.collection.update_one(
            {"_id": ObjectId(user_id)}, {"$set": update_data}
        )

        if result.modified_count == 0:
            # Check if the document truly doesn't exist
            if not await self.collection.find_one({"_id": ObjectId(user_id)}):
                return None  # User not found
            # If it exists but wasn't modified, return 304
            raise HTTPException(
                status_code=status.HTTP_304_NOT_MODIFIED,
                detail="User data not modified",
            )

        updated_user_doc = await self.collection.find_one({"_id": ObjectId(user_id)})
        if updated_user_doc:
            return await self._process_user_doc(updated_user_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve updated user",
        )

    async def delete_user(self, user_id: str) -> bool:
        """
        Deletes a user from the database by their ID.
        Returns True if deleted, False if not found.
        """
        if not ObjectId.is_valid(user_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        delete_result = await self.collection.delete_one({"_id": ObjectId(user_id)})
        return delete_result.deleted_count > 0
