from typing import List, Optional
from bson import ObjectId
from pymongo import AsyncMongoClient
from fastapi import HTTPException, status
from dockdinestay.db.utils import (
    default_time,
)


from dockdinestay.db.models import CafeteriaOrderItem


class CafeteriaOrderItemCRUD:
    """
    CRUD operations for the CafeteriaOrderItem collection (menu items).
    """

    def __init__(self, database: AsyncMongoClient):
        self.collection = (
            database.cafeteria_order_items
        )  # Access the 'cafeteria_order_items' collection

    async def _process_order_item_doc(self, item_doc: dict) -> CafeteriaOrderItem:
        """
        Helper method to process raw MongoDB document before Pydantic validation.
        Ensures _id (ObjectId) is converted to string for PyObjectId.
        """
        if item_doc and "_id" in item_doc and isinstance(item_doc["_id"], ObjectId):
            item_doc["id"] = str(item_doc["_id"])
            del item_doc["_id"]
        return CafeteriaOrderItem.model_validate(item_doc)

    async def create_item(self, item_data: CafeteriaOrderItem) -> CafeteriaOrderItem:
        """
        Creates a new cafeteria menu item in the database.
        Checks for duplicate item name.
        """
        if item_data.id:
            item_data.id = None  # Ensure ID is generated by default_factory or MongoDB

        # Check if item_name already exists (case-insensitive check might be better)
        if await self.collection.find_one(
            {"item_name": {"$regex": f"^{item_data.item_name}$", "$options": "i"}}
        ):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Menu item with name '{item_data.item_name}' already exists.",
            )

        # Set default values if not provided
        if not item_data.created_at:
            item_data.created_at = default_time()
        if not item_data.updated_at:
            item_data.updated_at = default_time()

        item_dict = item_data.model_dump(by_alias=True, exclude_unset=True)
        insert_result = await self.collection.insert_one(item_dict)

        created_item_doc = await self.collection.find_one(
            {"_id": insert_result.inserted_id}
        )
        if created_item_doc:
            return await self._process_order_item_doc(created_item_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create cafeteria menu item",
        )

    async def get_all_items(self) -> List[CafeteriaOrderItem]:
        """
        Retrieves all cafeteria menu items from the database.
        """
        items = []
        async for item_doc in self.collection.find():
            items.append(await self._process_order_item_doc(item_doc))
        return items

    async def get_item_by_id(self, item_id: str) -> Optional[CafeteriaOrderItem]:
        """
        Retrieves a single cafeteria menu item by its ID.
        """
        if not ObjectId.is_valid(item_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        item_doc = await self.collection.find_one({"_id": ObjectId(item_id)})
        if item_doc:
            return await self._process_order_item_doc(item_doc)
        return None

    async def update_item(
        self, item_id: str, item_data: CafeteriaOrderItem
    ) -> Optional[CafeteriaOrderItem]:
        """
        Updates an existing cafeteria menu item's information.
        """
        if not ObjectId.is_valid(item_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        update_data = item_data.model_dump(by_alias=True, exclude_unset=True)
        update_data.pop("_id", None)  # Ensure _id is not updated
        update_data.pop("id", None)  # Ensure 'id' is not updated

        # Prevent changing item_name to an existing one (if item_name is in update_data)
        if "item_name" in update_data:
            existing_item = await self.collection.find_one(
                {
                    "item_name": {
                        "$regex": f"^{update_data['item_name']}$",
                        "$options": "i",
                    },
                    "_id": {"$ne": ObjectId(item_id)},
                }
            )
            if existing_item:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Menu item with name '{update_data['item_name']}' already exists for another item.",
                )

        # Update updated_at timestamp
        update_data["updated_at"] = default_time()

        result = await self.collection.update_one(
            {"_id": ObjectId(item_id)}, {"$set": update_data}
        )

        if result.modified_count == 0:
            if not await self.collection.find_one({"_id": ObjectId(item_id)}):
                return None  # Item not found
            raise HTTPException(
                status_code=status.HTTP_304_NOT_MODIFIED,
                detail="Menu item data not modified",
            )

        updated_item_doc = await self.collection.find_one({"_id": ObjectId(item_id)})
        if updated_item_doc:
            return await self._process_order_item_doc(updated_item_doc)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve updated menu item",
        )

    async def delete_item(self, item_id: str) -> bool:
        """
        Deletes a cafeteria menu item from the database by its ID.
        Returns True if deleted, False if not found.
        """
        if not ObjectId.is_valid(item_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid ObjectId format",
            )

        delete_result = await self.collection.delete_one({"_id": ObjectId(item_id)})
        return delete_result.deleted_count > 0
